<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace which;

use \php\_Boot\HxAnon;
use \tink\core\_Future\SyncFuture;
use \php\Boot;
use \tink\core\TypedError;
use \tink\core\Outcome;
use \tink\core\_Lazy\LazyConst;
use \php\_Boot\HxString;
use \tink\core\_Future\Future_Impl_;
use \tink\core\_Promise\Promise_Impl_;
use \asys\FileSystem;
use \tink\core\FutureObject;
use \haxe\io\Path;

/**
 * Finds the instances of an executable in the system path.
 */
class Finder {

	/**
	 * @var \Array_hx
	 * The list of executable file extensions.
	 */
	public $extensions;
	/**
	 * @var \Array_hx
	 * The list of system paths.
	 */
	public $path;

	/**
	 * Gets a value indicating whether the current platform is Windows.
	 * 
	 * @return bool
	 */
	public static function get_isWindows () {
		if (\Sys::systemName() !== "Windows") {
			$osType = \Sys::getEnv("OSTYPE");
			if ($osType !== "cygwin") {
				return $osType === "msys";
			} else {
				return true;
			}
		} else {
			return true;
		}
	}

	/**
	 * Creates a new finder.
	 * 
	 * @param object $options
	 * 
	 * @return void
	 */
	public function __construct ($options = null) {
		$separator = (Finder::get_isWindows() ? ";" : ":");
		$pathExt = \Sys::getEnv("PATHEXT");
		$tmp = null;
		if ($pathExt !== null) {
			$_this = HxString::split($pathExt, $separator);
			$result = [];
			$data = $_this->arr;
			$_g_current = 0;
			$_g_length = \count($data);
			while ($_g_current < $_g_length) {
				$result[] = \mb_strtolower($data[$_g_current++]);
			}
			$tmp = \Array_hx::wrap($result);
		} else {
			$tmp = \Array_hx::wrap([
				".exe",
				".cmd",
				".bat",
				".com",
			]);
		}
		$this->extensions = $tmp;
		$pathEnv = \Sys::getEnv("PATH");
		$this->path = ($pathEnv !== null ? HxString::split($pathEnv, $separator) : new \Array_hx());
		if ($options !== null) {
			if ($options->extensions !== null) {
				$_this = $options->extensions;
				$result = [];
				$data = $_this->arr;
				$_g_current = 0;
				$_g_length = \count($data);
				while ($_g_current < $_g_length) {
					$result[] = \mb_strtolower($data[$_g_current++]);
				}
				$this->extensions = \Array_hx::wrap($result);
			}
			if ($options->path !== null) {
				$this->path = $options->path;
			}
		}
	}

	/**
	 * Removes the duplicate values from the specified `array`.
	 * 
	 * @param \Array_hx $array
	 * 
	 * @return \Array_hx
	 */
	public function arrayUnique ($array) {
		$list = new \Array_hx();
		$_g = 0;
		while ($_g < $array->length) {
			$value = ($array->arr[$_g] ?? null);
			++$_g;
			if ($list->indexOf($value) === -1) {
				$list->arr[$list->length++] = $value;
			}
		}
		return $list;
	}

	/**
	 * Checks that the specified `file` is executable according to the executable file extensions.
	 * 
	 * @param string $file
	 * 
	 * @return bool
	 */
	public function checkFileExtension ($file) {
		return $this->extensions->indexOf("." . (\mb_strtolower(Path::extension($file))??'null')) !== -1;
	}

	/**
	 * Checks that the file represented by the specified `stats` is executable according to its permissions.
	 * 
	 * @param object $stat
	 * 
	 * @return FutureObject
	 */
	public function checkFilePermissions ($stat) {
		$processUid = -1;
		return Promise_Impl_::next(Promise_Impl_::next(Future_Impl_::next(new SyncFuture(new LazyConst(($stat->mode & 1) !== 0)), function ($isExec) use (&$stat) {
			if ($isExec || (($stat->mode & 8) === 0)) {
				return new SyncFuture(new LazyConst(Outcome::Success(true)));
			} else {
				return Promise_Impl_::next(Process::get_gid(), function ($gid) use (&$stat) {
					return new SyncFuture(new LazyConst(Outcome::Success($stat->gid === $gid)));
				});
			}
		}), function ($isExec) use (&$stat, &$processUid) {
			if ($isExec || (($stat->mode & 64) === 0)) {
				return new SyncFuture(new LazyConst(Outcome::Success(true)));
			} else {
				return Promise_Impl_::next(Process::get_uid(), function ($uid) use (&$stat, &$processUid) {
					$processUid = $uid;
					return new SyncFuture(new LazyConst(Outcome::Success($stat->uid === $uid)));
				});
			}
		}), function ($isExec) use (&$stat, &$processUid) {
			if ($isExec || (($stat->mode & 72) === 0)) {
				return new SyncFuture(new LazyConst(Outcome::Success(true)));
			} else {
				return new SyncFuture(new LazyConst(Outcome::Success($processUid === 0)));
			}
		})->flatMap(function ($o) {
			$__hx__switch = ($o->index);
			if ($__hx__switch === 0) {
				return new SyncFuture(new LazyConst($o->params[0]));
			} else if ($__hx__switch === 1) {
				return new SyncFuture(new LazyConst(false));
			}
		})->gather();
	}

	/**
	 * Finds the instances of the specified `command` in the system path.
	 * 
	 * @param string $command
	 * 
	 * @return FutureObject
	 */
	public function find ($command) {
		$_gthis = $this;
		$_this = Boot::deref(((Finder::get_isWindows() ? \Array_hx::wrap([\Sys::getCwd()]) : new \Array_hx())))->concat($this->path);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		while ($_g_current < $_g_length) {
			$result[] = $_gthis->findExecutables($data[$_g_current++], $command);
		}
		return Promise_Impl_::next(Promise_Impl_::inParallel(\Array_hx::wrap($result)), function ($results) use (&$_gthis) {
			$_gthis1 = $_gthis;
			$_g = new \Array_hx();
			$_g_current = 0;
			while ($_g_current < $results->length) {
				$x = ($results->arr[$_g_current++] ?? null)->iterator();
				while ($x->hasNext()) {
					$x1 = $x->next();
					$_g->arr[$_g->length++] = $x1;
				}
			}
			return new SyncFuture(new LazyConst(Outcome::Success($_gthis1->arrayUnique($_g))));
		});
	}

	/**
	 * Finds the instances of the specified `command` in the given `directory`.
	 * 
	 * @param string $directory
	 * @param string $command
	 * 
	 * @return FutureObject
	 */
	public function findExecutables ($directory, $command) {
		$_gthis = $this;
		$basePath = FileSystem::absolutePath($directory);
		$_this = (\Array_hx::wrap([""]))->concat((Finder::get_isWindows() ? $this->extensions : new \Array_hx()));
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		while ($_g_current < $_g_length) {
			$result[] = \StringTools::replace(Path::join(\Array_hx::wrap([
				$basePath,
				"" . ($command??'null') . ($data[$_g_current++]??'null'),
			])), "/", (Finder::get_isWindows() ? "\\" : "/"));
		}
		$paths = \Array_hx::wrap($result);
		$result = [];
		$data = $paths->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		while ($_g_current < $_g_length) {
			$result[] = $_gthis->isExecutable($data[$_g_current++]);
		}
		return Promise_Impl_::next(Promise_Impl_::inParallel(\Array_hx::wrap($result)), function ($results) use (&$paths) {
			$_g = new \Array_hx();
			$_g1_current = 0;
			while ($_g1_current < $results->length) {
				if (($results->arr[$_g1_current++] ?? null)) {
					$paths1 = ($paths->arr[$_g1_current - 1] ?? null);
					$_g->arr[$_g->length++] = $paths1;
				}
			}
			return new SyncFuture(new LazyConst(Outcome::Success($_g)));
		});
	}

	/**
	 * Gets a value indicating whether the specified `file` is executable.
	 * 
	 * @param string $file
	 * 
	 * @return FutureObject
	 */
	public function isExecutable ($file) {
		$_gthis = $this;
		return Promise_Impl_::next(Promise_Impl_::next(Future_Impl_::next(FileSystem::exists($file), function ($exists) use (&$file) {
			if ($exists) {
				return FileSystem::isDirectory($file)->map(Boot::getStaticClosure(Outcome::class, 'Success'))->gather();
			} else {
				return new SyncFuture(new LazyConst(Outcome::Failure(new TypedError(404, $file, new HxAnon([
					"fileName" => "src/which/Finder.hx",
					"lineNumber" => 53,
					"className" => "which.Finder",
					"methodName" => "isExecutable",
				])))));
			}
		}), function ($isDirectory) use (&$file) {
			if ($isDirectory) {
				return new SyncFuture(new LazyConst(Outcome::Failure(new TypedError(422, $file, new HxAnon([
					"fileName" => "src/which/Finder.hx",
					"lineNumber" => 54,
					"className" => "which.Finder",
					"methodName" => "isExecutable",
				])))));
			} else {
				return new SyncFuture(new LazyConst(Outcome::Success($file)));
			}
		}), function ($_) use (&$file, &$_gthis) {
			if (Finder::get_isWindows()) {
				return new SyncFuture(new LazyConst(Outcome::Success($_gthis->checkFileExtension($file))));
			} else {
				return Promise_Impl_::next(FileSystem::stat($file), function ($stat) use (&$_gthis) {
					return $_gthis->checkFilePermissions($stat)->map(Boot::getStaticClosure(Outcome::class, 'Success'))->gather();
				});
			}
		})->flatMap(function ($o) {
			$__hx__switch = ($o->index);
			if ($__hx__switch === 0) {
				return new SyncFuture(new LazyConst($o->params[0]));
			} else if ($__hx__switch === 1) {
				return new SyncFuture(new LazyConst(false));
			}
		})->gather()->map(Boot::getStaticClosure(Outcome::class, 'Success'))->gather();
	}
}

Boot::registerClass(Finder::class, 'which.Finder');
Boot::registerGetters('which\\Finder', [
	'isWindows' => true
]);
