<?php
/**
 * Generated by Haxe 4.1.2
 */

namespace which;

use \php\_Boot\HxDynamicStr;
use \thenshim\PromiseTools;
use \php\Boot;
use \php\_Boot\HxString;
use \thenshim\_Promise\Promise_Impl_;
use \sys\FileSystem;
use \thenshim\Thenable;
use \haxe\io\Path;

/**
 * Finds the instances of an executable in the system path.
 */
class Finder {
	/**
	 * @var bool
	 * Value indicating whether the current platform is Windows.
	 */
	static public $isWindows;

	/**
	 * @var \Array_hx
	 * The list of executable file extensions.
	 */
	public $extensions;
	/**
	 * @var \Array_hx
	 * The list of system paths.
	 */
	public $path;

	/**
	 * Gets a value indicating whether the current platform is Windows.
	 * 
	 * @return bool
	 */
	public static function get_isWindows () {
		if (Finder::$isWindows === null) {
			$tmp = null;
			if (\Sys::systemName() !== "Windows") {
				$osType = \Sys::getEnv("OSTYPE");
				$tmp = ($osType === "cygwin") || ($osType === "msys");
			} else {
				$tmp = true;
			}
			Finder::$isWindows = $tmp;
		}
		return Finder::$isWindows;
	}

	/**
	 * Creates a new finder.
	 * 
	 * @param mixed $options
	 * 
	 * @return void
	 */
	public function __construct ($options = null) {
		$separator = (Finder::get_isWindows() ? ";" : ":");
		$pathExt = \Sys::getEnv("PATHEXT");
		$tmp = null;
		if ($pathExt !== null) {
			$_this = HxString::split($pathExt, $separator);
			$result = [];
			$data = $_this->arr;
			$_g_current = 0;
			$_g_length = count($data);
			while ($_g_current < $_g_length) {
				$result[] = mb_strtolower($data[$_g_current++]);
			}
			$tmp = \Array_hx::wrap($result);
		} else {
			$tmp = \Array_hx::wrap([
				".exe",
				".cmd",
				".bat",
				".com",
			]);
		}
		$this->extensions = $tmp;
		$pathEnv = \Sys::getEnv("PATH");
		$this->path = ($pathEnv !== null ? HxString::split($pathEnv, $separator) : new \Array_hx());
		if ($options !== null) {
			if (isset($options["extensions"])) {
				$this->extensions = $options["extensions"]->map(function ($item) {
					return HxDynamicStr::wrap($item)->toLowerCase();
				});
			}
			if (isset($options["path"])) {
				$this->path = $options["path"];
			}
		}
	}

	/**
	 * Checks that the specified `file` is executable according to the executable file extensions.
	 * 
	 * @param string $file
	 * 
	 * @return bool
	 */
	public function checkFileExtension ($file) {
		$extension = mb_strtolower(Path::extension($file));
		if (mb_strlen($extension) > 0) {
			return $this->extensions->indexOf("." . ($extension??'null')) !== -1;
		} else {
			return false;
		}
	}

	/**
	 * Checks that the file represented by the specified `stats` is executable according to its permissions.
	 * 
	 * @param object $stats
	 * 
	 * @return Thenable
	 */
	public function checkFilePermissions ($stats) {
		$procUid = -1;
		return Promise_Impl_::then(Promise_Impl_::then(Promise_Impl_::then(Promise_Impl_::resolve(($stats->mode & 1) !== 0), function ($isExec) use (&$stats) {
			if ($isExec || (($stats->mode & 8) === 0)) {
				return Promise_Impl_::resolve($isExec);
			} else {
				return Promise_Impl_::then(Process::get_gid(), function ($gid) use (&$stats) {
					return $stats->gid === $gid;
				});
			}
		}), function ($isExec) use (&$stats, &$procUid) {
			if ($isExec || (($stats->mode & 64) === 0)) {
				return Promise_Impl_::resolve($isExec);
			} else {
				return Promise_Impl_::then(Process::get_uid(), function ($uid) use (&$stats, &$procUid) {
					$procUid = $uid;
					return $stats->uid === $uid;
				});
			}
		}), function ($isExec) use (&$stats, &$procUid) {
			if ($isExec || (($stats->mode & 72) === 0)) {
				return $isExec;
			} else {
				return $procUid === 0;
			}
		});
	}

	/**
	 * Finds the instances of the specified `command` in the system path.
	 * 
	 * @param string $command
	 * 
	 * @return Thenable
	 */
	public function find ($command) {
		$_gthis = $this;
		$_this = Boot::deref(((Finder::get_isWindows() ? \Array_hx::wrap([\Sys::getCwd()]) : new \Array_hx())))->concat($this->path);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = count($data);
		while ($_g_current < $_g_length) {
			$result[] = $_gthis->findExecutables($data[$_g_current++], $command);
		}
		return Promise_Impl_::then(PromiseTools::all(\Array_hx::wrap($result)), function ($results) {
			$_g = new \Array_hx();
			$_g_current = 0;
			while ($_g_current < $results->length) {
				$x = ($results->arr[$_g_current++] ?? null)->iterator();
				while ($x->hasNext()) {
					$x1 = $x->next();
					$_g->arr[$_g->length++] = $x1;
				}
			}
			return $_g;
		});
	}

	/**
	 * Finds the instances of the specified `command` in the given `directory`.
	 * 
	 * @param string $directory
	 * @param string $command
	 * 
	 * @return Thenable
	 */
	public function findExecutables ($directory, $command) {
		$_gthis = $this;
		$basePath = (Path::isAbsolute($directory) ? $directory : Path::join(\Array_hx::wrap([
			\Sys::getCwd(),
			$directory,
		])));
		$_this = (\Array_hx::wrap([""]))->concat((Finder::get_isWindows() ? $this->extensions : new \Array_hx()));
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = count($data);
		while ($_g_current < $_g_length) {
			$result[] = \StringTools::replace(Path::join(\Array_hx::wrap([
				$basePath,
				"" . ($command??'null') . ($data[$_g_current++]??'null'),
			])), "/", (Finder::get_isWindows() ? "\\" : "/"));
		}
		$paths = \Array_hx::wrap($result);
		$result = [];
		$data = $paths->arr;
		$_g_current = 0;
		$_g_length = count($data);
		while ($_g_current < $_g_length) {
			$result[] = $_gthis->isExecutable($data[$_g_current++]);
		}
		return Promise_Impl_::then(PromiseTools::all(\Array_hx::wrap($result)), function ($results) use (&$paths) {
			$_g = new \Array_hx();
			$_g1_current = 0;
			while ($_g1_current < $results->length) {
				if (($results->arr[$_g1_current++] ?? null)) {
					$paths1 = ($paths->arr[$_g1_current - 1] ?? null);
					$_g->arr[$_g->length++] = $paths1;
				}
			}
			return $_g;
		});
	}

	/**
	 * Gets a value indicating whether the specified `file` is executable.
	 * 
	 * @param string $file
	 * 
	 * @return Thenable
	 */
	public function isExecutable ($file) {
		clearstatcache(true, $file);
		if (!file_exists($file) || FileSystem::isDirectory($file)) {
			return Promise_Impl_::resolve(false);
		}
		if (is_executable($file)) {
			return Promise_Impl_::resolve(true);
		}
		if (Finder::get_isWindows()) {
			return Promise_Impl_::resolve($this->checkFileExtension($file));
		} else {
			return $this->checkFilePermissions(FileSystem::stat($file));
		}
	}
}

Boot::registerClass(Finder::class, 'which.Finder');
Boot::registerGetters('which\\Finder', [
	'isWindows' => true
]);
