<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace which;

use \php\_Boot\HxAnon;
use \tink\core\_Future\SyncFuture;
use \php\Boot;
use \tink\streams\_Stream\Stream_Impl_;
use \haxe\Log;
use \tink\core\TypedError;
use \tink\streams\StreamObject;
use \tink\core\Outcome;
use \tink\core\_Lazy\LazyConst;
use \php\_Boot\HxString;
use \tink\streams\Empty_hx;
use \tink\core\_Future\Future_Impl_;
use \tink\core\_Promise\Promise_Impl_;
use \asys\FileSystem;
use \tink\streams\_Stream\Filter_Impl_;
use \tink\core\FutureObject;
use \haxe\io\Path;
use \haxe\iterators\ArrayIterator;

/**
 * Finds the instances of an executable in the system path.
 */
class Finder {

	/**
	 * @var \Array_hx
	 * The list of executable file extensions.
	 */
	public $extensions;
	/**
	 * @var \Array_hx
	 * The list of system paths.
	 */
	public $path;

	/**
	 * Gets a value indicating whether the current platform is Windows.
	 * 
	 * @return bool
	 */
	public static function get_isWindows () {
		if (\Sys::systemName() !== "Windows") {
			$osType = \Sys::getEnv("OSTYPE");
			if ($osType !== "cygwin") {
				return $osType === "msys";
			} else {
				return true;
			}
		} else {
			return true;
		}
	}

	/**
	 * Creates a new finder.
	 * 
	 * @param object $options
	 * 
	 * @return void
	 */
	public function __construct ($options = null) {
		$separator = (Finder::get_isWindows() ? ";" : ":");
		$pathExt = \Sys::getEnv("PATHEXT");
		$tmp = null;
		if ($pathExt !== null) {
			$_this = HxString::split($pathExt, $separator);
			$result = [];
			$data = $_this->arr;
			$_g_current = 0;
			$_g_length = \count($data);
			while ($_g_current < $_g_length) {
				$result[] = \mb_strtolower($data[$_g_current++]);
			}
			$tmp = \Array_hx::wrap($result);
		} else {
			$tmp = \Array_hx::wrap([
				".exe",
				".cmd",
				".bat",
				".com",
			]);
		}
		$this->extensions = $tmp;
		$pathEnv = \Sys::getEnv("PATH");
		$this->path = ($pathEnv !== null ? HxString::split($pathEnv, $separator) : new \Array_hx());
		if ($options !== null) {
			if ($options->extensions !== null) {
				$_this = $options->extensions;
				$result = [];
				$data = $_this->arr;
				$_g_current = 0;
				$_g_length = \count($data);
				while ($_g_current < $_g_length) {
					$result[] = \mb_strtolower($data[$_g_current++]);
				}
				$this->extensions = \Array_hx::wrap($result);
			}
			if ($options->path !== null) {
				$this->path = $options->path;
			}
		}
	}

	/**
	 * Checks that the specified `file` is executable according to the executable file extensions.
	 * 
	 * @param string $file
	 * 
	 * @return bool
	 */
	public function checkFileExtension ($file) {
		return $this->extensions->indexOf("." . (\mb_strtolower(Path::extension($file))??'null')) !== -1;
	}

	/**
	 * Checks that the file represented by the specified `stats` is executable according to its permissions.
	 * 
	 * @param object $stat
	 * 
	 * @return FutureObject
	 */
	public function checkFilePermissions ($stat) {
		$processUid = -1;
		return Promise_Impl_::next(Promise_Impl_::next(Future_Impl_::next(new SyncFuture(new LazyConst(($stat->mode & 1) !== 0)), function ($isExec) use (&$stat) {
			if ($isExec || (($stat->mode & 8) === 0)) {
				return new SyncFuture(new LazyConst(Outcome::Success($isExec)));
			} else {
				return Promise_Impl_::next(Process::get_gid(), function ($gid) use (&$stat) {
					return new SyncFuture(new LazyConst(Outcome::Success($stat->gid === $gid)));
				});
			}
		}), function ($isExec) use (&$stat, &$processUid) {
			if ($isExec || (($stat->mode & 64) === 0)) {
				return new SyncFuture(new LazyConst(Outcome::Success($isExec)));
			} else {
				return Promise_Impl_::next(Process::get_uid(), function ($uid) use (&$stat, &$processUid) {
					$processUid = $uid;
					return new SyncFuture(new LazyConst(Outcome::Success($stat->uid === $uid)));
				});
			}
		}), function ($isExec) use (&$stat, &$processUid) {
			if ($isExec || (($stat->mode & 72) === 0)) {
				return new SyncFuture(new LazyConst(Outcome::Success($isExec)));
			} else {
				return new SyncFuture(new LazyConst(Outcome::Success($processUid === 0)));
			}
		});
	}

	/**
	 * Finds the instances of the specified `command` in the system path.
	 * 
	 * @param string $command
	 * 
	 * @return StreamObject
	 */
	public function find ($command) {
		$stream = Empty_hx::$inst;
		$_g = 0;
		$_g1 = Boot::deref(((Finder::get_isWindows() ? \Array_hx::wrap([\Sys::getCwd()]) : new \Array_hx())))->concat($this->path);
		while ($_g < $_g1->length) {
			$stream = $stream->append($this->findExecutables(($_g1->arr[$_g++] ?? null), $command));
		}
		return $stream;
	}

	/**
	 * Finds the instances of the specified `command` in the given `directory`.
	 * 
	 * @param string $directory
	 * @param string $command
	 * 
	 * @return StreamObject
	 */
	public function findExecutables ($directory, $command) {
		$_gthis = $this;
		$basePath = FileSystem::absolutePath($directory);
		$_this = (\Array_hx::wrap([""]))->concat((Finder::get_isWindows() ? $this->extensions : new \Array_hx()));
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		while ($_g_current < $_g_length) {
			$result[] = \StringTools::replace(Path::join(\Array_hx::wrap([
				$basePath,
				"" . ($command??'null') . ($data[$_g_current++]??'null'),
			])), "/", (Finder::get_isWindows() ? "\\" : "/"));
		}
		return Stream_Impl_::ofIterator(new ArrayIterator(\Array_hx::wrap($result)))->filter(Filter_Impl_::ofAsync(function ($item) use (&$_gthis) {
			(Log::$trace)($item, new HxAnon([
				"fileName" => "src/which/Finder.hx",
				"lineNumber" => 82,
				"className" => "which.Finder",
				"methodName" => "findExecutables",
			]));
			return $_gthis->isExecutable($item)->flatMap(function ($o) {
				$__hx__switch = ($o->index);
				if ($__hx__switch === 0) {
					return new SyncFuture(new LazyConst($o->params[0]));
				} else if ($__hx__switch === 1) {
					return new SyncFuture(new LazyConst(false));
				}
			})->gather();
		}));
	}

	/**
	 * Gets a value indicating whether the specified `file` is executable.
	 * 
	 * @param string $file
	 * 
	 * @return FutureObject
	 */
	public function isExecutable ($file) {
		$_gthis = $this;
		return Promise_Impl_::next(Promise_Impl_::next(Future_Impl_::next(FileSystem::exists($file), function ($exists) use (&$file) {
			if ($exists) {
				return FileSystem::isDirectory($file)->map(Boot::getStaticClosure(Outcome::class, 'Success'))->gather();
			} else {
				return new SyncFuture(new LazyConst(Outcome::Failure(new TypedError(404, $file, new HxAnon([
					"fileName" => "src/which/Finder.hx",
					"lineNumber" => 56,
					"className" => "which.Finder",
					"methodName" => "isExecutable",
				])))));
			}
		}), function ($isDirectory) use (&$file) {
			if ($isDirectory) {
				return new SyncFuture(new LazyConst(Outcome::Failure(new TypedError(422, $file, new HxAnon([
					"fileName" => "src/which/Finder.hx",
					"lineNumber" => 57,
					"className" => "which.Finder",
					"methodName" => "isExecutable",
				])))));
			} else {
				return new SyncFuture(new LazyConst(Outcome::Success($file)));
			}
		}), function ($_) use (&$file, &$_gthis) {
			if (Finder::get_isWindows()) {
				return new SyncFuture(new LazyConst(Outcome::Success($_gthis->checkFileExtension($file))));
			} else {
				return Promise_Impl_::next(FileSystem::stat($file), Boot::getInstanceClosure($_gthis, 'checkFilePermissions'));
			}
		});
	}
}

Boot::registerClass(Finder::class, 'which.Finder');
Boot::registerGetters('which\\Finder', [
	'isWindows' => true
]);
